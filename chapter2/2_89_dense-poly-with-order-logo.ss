(define (the-empty-termlist) '())
;;BECARE:here we dont need to add the logo of biggest-order in term-list
;;       but it may make the operations faster
(define (make-termlist coeff-list)
  (if (null? coeff-list)
      (the-empty-termlist)
      (cons (- (length coeff-list) 1) coeff-list)))
;;'(<biggest-order> coeff-1 coeff-2 ...)

(define (make-term order coeff)
  (list order coeff));;(order coeff)
;;actually the same as a term-list whose length is 1

;;we need to define the biggest order
(define (first-coeff term-list) (car (coeff-list term-list)))
(define (rest-coeffs term-list) (cdr (coeff-list term-list)))
(define (coeff-list term-list) 
  (if (empty-termlist? term-list)
      '()
      (cdr term-list)))

(define (biggest-order term-list) (car term-list))
(define (first-term term-list)
  (make-term (biggest-order term-list) (first-coeff term-list)))
(define (rest-terms term-list)
  (make-termlist (rest-coeffs term-list)))
(define (empty-termlist? term-list)
  (null? term-list))

(define (add-terms l1 l2)
  (cond ((empty-termlist? l1) l2)
        ((empty-termlist? l2) l1)
        (else (let ((bo1 (biggest-order l1))
                    (bo2 (biggest-order l2)))
                (cond ((> bo1 bo2)
                       (adjoin-term (first-term l1)
                                    (add-terms (rest-terms l1) l2)))
                      ((< bo1 bo2)
                       (adjoin-term (first-term l2)
                                    (add-terms l1 (rest-terms l2))))
                      (else 
                       (adjoin-term (make-term bo1
                                               (add (first-coeff l1)
                                                    (first-coeff l2)))
                                    (add-terms (rest-terms l1)
                                               (rest-terms l2)))))))))
;;helper
(define (adjoin-term term term-list)
  (make-termlist (cons (cadr term) (coeff-list term-list))))

;;cause the polies are both dense, so we can
(define (add-terms-1 l1 l2)
  (cond ((empty-termlist? l1) l2)
        ((empty-termlist? l2) l1)
        (else (let ((bo1 (biggest-order l1))
                    (bo2 (biggest-order l2))
                    (coes1 (coeff-list l1))
                    (coes2 (coeff-list l2))
                    )
                (cond ((> bo1 bo2)
                       (let ((result-pair (split-list (- bo1 bo2) coes1)))
                         (make-termlist (append (car result-pair)
                                                (map add 
                                                     (cdr result-pair)
                                                     coes2)))))
                      ((< bo1 bo2)
                       (let ((result-pair (split-list (- bo2 bo1) coes2)))
                         (make-termlist (append (car result-pair)
                                                (map add
                                                     (cdr result-pair)
                                                     coes1)))))
                      (else
                       (make-termlist (map add coes1 coes2))))))))
(define (mul-terms l1 l2)
  (if (empty-termlist? l1)
      (the-empty-termlist)
      (add-terms-1 (make-termlist (mul-term-by-coes (first-term l1) (coeff-list l2)))
                   (mul-terms (rest-terms l1) l2))))
(define (mul-term-by-coes term coes)
  (append (map (lambda (coe)
                 (* coe (cadr term)))
               coes)
          (build-list-from-num-val (car term) 0)))
;;
(load "d:\\sicp\\chapter2\\split-list.ss")
(define (test-code)
  (define add +)
  (define tl1 (make-termlist '(1 2 3 4)))
  (define tl2 (make-termlist '(2 3 4 5)))
  (define tl3 (make-termlist '(1 2 3)))
  (display tl1)
  (display (add-terms tl1 tl2))
  (display (add-terms tl2 tl1))
  (display (add-terms tl1 tl3))
  (display (mul-terms tl1 tl2))
  (display (mul-terms tl1 tl3))
  'test-done)
(define add +)
;(define mul *)
(test-code)