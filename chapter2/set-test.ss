;;set-test
(define (element-of-set? x set)
  (if (nil-leaf? set)
      #f
      (let ((e (entry set)))
           (cond ((= e x) #t)
              ((> e x) (element-of-set? x (left-branch set)))
              ((< e x) (element-of-set? x (right-branch set)))))))
;;
(define (adjoin-set x set)
  (if (nil-leaf? set)
      (make-tree x '() '())
      (let ((e (entry set)))
        (cond ((= x e) set)
              ((< x e) (make-tree e (adjoin-set x (left-branch set))
                             (right-branch set)))
              ((> x e) (make-tree e (left-branch set)
                             (adjoin-set x (right-branch set))))))))
(load "d:\\sicp\\chapter2\\list-tree-set.ss")
;(load "d:\\sicp\\chapter2\\pro-tree-set.ss")
(define t (make-tree 6 
                     (make-tree 4 
                                (make-tree 3 '() '()) (make-tree 5 '() '())) 
                     (make-tree 7 '() '())
                     ))
(define et (make-tree 3 '() '()))
(entry et)
(left-branch et)
(right-branch et)
;;test
(element-of-set? 1 t)
(element-of-set? 3 t)
(element-of-set? 4 t)
(element-of-set? 5 t)
(element-of-set? 6 t)
(element-of-set? 7 t)
;;
(define t+1 (adjoin-set 1 t))
(element-of-set? 1 t+1)
(element-of-set? 3 t+1)
(element-of-set? 4 t+1)
(element-of-set? 5 t+1)
(element-of-set? 6 t+1)
(element-of-set? 7 t+1)
;(newline)
;(display t)